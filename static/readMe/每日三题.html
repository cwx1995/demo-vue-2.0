<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>每日三题</title>
</head>
<body>
    1.js8种数据类型
    值类型：string number undefined null boolean symbol bigInt
    引用类型：object ==》 Array function Date

    2.js堆栈运行机制
    栈：代码运行的环境，存放值类型，当栈销毁，基本数据类型也随之销毁。
    堆：存储引用数据类型，浏览器会自主进行回收（没有被占用的和0引用的）。
    全局对象GO：window指向GO，浏览器内置方法的存放。
    执行上下文EC：代码自己执行所在的环境。函数会私有一个执行上下文，进入到栈运行，运行后出栈释放。
    变量对象VO：在当前上下文中，存放变量和值的地方。
    堆释放：让引用类型数据指向null
    栈释放：函数执行完毕自动释放（除了闭包）

    3.js变量提升
    代码预解析时，var会被提升到作用域最顶端，会以undefined的形势先声明，所以console不会报错。
    let和const不提升。
    function声明提升时，整个代码块提升到最开始运行，在var之后。 如：function foo(){}
    字面量定义函数不会提升。 如：foo=function(){}

    4.作用域与作用域链
    全局变量：var声明的变量。页面任何位置都可以使用，页面不关闭就不会释放。
    局部变量：函数内定义的变量，函数外不可使用。
    局部作用域：局部变量可以使用的范围。
    全局作用域：全局变量可以使用的范围。
    块级作用域：一对大括号为一块。js没有块级作用域，函数除外。
    隐式全局变量：没有用var声明，可以被删除，且全局使用。如：number:function f(){number=100} f();
    作用域链：js自由变量 逐层向上级作用域寻找参数 一直找到全局作用域 这一层层关系成为作用域链。

    5.闭包
    保护与保存机制
    有权访问另一个函数作用域中的变量的函数  函数嵌套函数
    作用：内部函数访问外部函数的属性，减少变量污染。且外部变量不会被系统回收。
    缺点：占用内存，消耗较大。

    6.js编译机制 vo/ao/go
    js编译环境：
        浏览器引擎、node、webview
    ESC：执行环境栈
        为栈内存分割，先进后出原则。用来存储（EC）执行上下文，保证代码有序执行
    EC：执行上下文
        栈内存，代码执行的作用域，为了区分全局作用域和函数执行作用域。
    EC（G）：全局执行上下文
        页面打开首次加载js时创建，只创建一次，刷新后释放重建。
    EC（xx）：xx函数执行上下文（私有）
        EC（G）入栈后，每当有函数调用都会创建并如栈，即使重复函数调用依然会创建。
        私有上下文互不干涉（*闭包保护机制） 函数执行后出栈
        当上下文中的某些内容被外部占用，则不会释放该上下文（*闭包的保存机制）
    VO（G）：（全局）变量对象
        VO用来保存当前执行上下文中的所有变量的对象，被创建在当前执行上下文中。
        带VAR 相当于给VO（G）加一个变量，同时映射给window （window设置属性）
        不带VAR 相当于只给window映射属性
    AO：私有变量对象
    GO：全局对象
        与VO无关。
        浏览器将js所需的所有属性和方法存放内置GO中，并创建一个全局对象window，将window指向GO
        所有window上的属性和方法都来自GO

</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>每日三题</title>
    <style>
        .img-style{
            width: 70%;
            margin-top: 50px;
        }
        img{
            width: 100%;
        }
    </style>
</head>
<body>
    <div>原型图</div>
    <div class="img-style">
        <img src="/static/images/原型链.png" alt="">
    </div>
</body>
</html>
<script type="text/javaScript">
    1.js8种数据类型
    值类型：string number undefined null boolean symbol bigInt
    引用类型：object ==》 Array function Date

    2.js堆栈运行机制
    栈：代码运行的环境，存放值类型，当栈销毁，基本数据类型也随之销毁。
    堆：存储引用数据类型，浏览器会自主进行回收（没有被占用的和0引用的）。
    全局对象GO：window指向GO，浏览器内置方法的存放。
    执行上下文EC：代码自己执行所在的环境。函数会私有一个执行上下文，进入到栈运行，运行后出栈释放。
    变量对象VO：在当前上下文中，存放变量和值的地方。
    堆释放：让引用类型数据指向null
    栈释放：函数执行完毕自动释放（除了闭包）

    3.js变量提升
    代码预解析时，var会被提升到作用域最顶端，会以undefined的形势先声明，所以console不会报错。
    let和const不提升。
    function声明提升时，整个代码块提升到最开始运行，在var之后。 如：function foo(){}
    字面量定义函数不会提升。 如：foo=function(){}

    4.作用域与作用域链
    全局变量：var声明的变量。页面任何位置都可以使用，页面不关闭就不会释放。
    局部变量：函数内定义的变量，函数外不可使用。
    局部作用域：局部变量可以使用的范围。
    全局作用域：全局变量可以使用的范围。
    块级作用域：一对大括号为一块。js没有块级作用域，函数除外。
    隐式全局变量：没有用var声明，可以被删除，且全局使用。如：number:function f(){number=100} f();
    作用域链：js自由变量 逐层向上级作用域寻找参数 一直找到全局作用域 这一层层关系成为作用域链。

    5.闭包
    保护与保存机制
    有权访问另一个函数作用域中的变量的函数  函数嵌套函数
    作用：内部函数访问外部函数的属性，减少变量污染。且外部变量不会被系统回收。
    缺点：占用内存，消耗较大。

    6.js编译机制 vo/ao/go
    js编译环境：
        浏览器引擎、node、webview
    ESC：执行环境栈
        为栈内存分割，先进后出原则。用来存储（EC）执行上下文，保证代码有序执行
    EC：执行上下文
        栈内存，代码执行的作用域，为了区分全局作用域和函数执行作用域。
    EC（G）：全局执行上下文
        页面打开首次加载js时创建，只创建一次，刷新后释放重建。
    EC（xx）：xx函数执行上下文（私有）
        EC（G）入栈后，每当有函数调用都会创建并如栈，即使重复函数调用依然会创建。
        私有上下文互不干涉（*闭包保护机制） 函数执行后出栈
        当上下文中的某些内容被外部占用，则不会释放该上下文（*闭包的保存机制）
    VO（G）：（全局）变量对象
        VO用来保存当前执行上下文中的所有变量的对象，被创建在当前执行上下文中。
        带VAR 相当于给VO（G）加一个变量，同时映射给window （window设置属性）
        不带VAR 相当于只给window映射属性
    AO：私有变量对象
    GO：全局对象
        与VO无关。
        浏览器将js所需的所有属性和方法存放内置GO中，并创建一个全局对象window，将window指向GO
        所有window上的属性和方法都来自GO

    7.惰性函数，函数柯里化，级联函数
    高阶函数：函数可以作为参数或函数可以作为返回值输出。
    惰性函数：表示函数执行的分支只会在函数第一次调用时执行，在第一次调用过程中，该函数被覆盖
    如判断浏览器类型：
    function A(type){
        if(type){
            console.log('chrome')
        }else{
            console.log('ie')
        }
    }
    *上述函数会一直执行，然而这种判断执行一次即可完成任务
    使用惰性函数写法：
    function A(type) {
        if(type){
            A=function () {
               console.log('chrome') 
            }
        }else{
            A=function () {
                console.log('ie')
            }
        }
    }
    函数柯里化：把接收多个参数的函数变成接收单一参数的函数。
    *只传一部分参数来调用函数，让函数返回另一个函数处理逻辑（闭包）
    如：
    function  A(x,y) {
        return x+y
    }
    A(1,2) //3
    柯里化为：
    function A(x) {
        return function (y) {
            return x+y
        }
    }
    A(1)(2) //3
    级联函数：指函数的链式调用
    如： a.setName().setAge().setJob() ...

    8.单例设计模式
    被称为单体模式，是只允许实例化一次的对象类。为js命名空间提供者，从全局命名空间提供一个唯一的访问点来访问该对象。
    一般是先判断实例是否已经存在，存在直接返回，不存在则创建后再返回。
    *例如一个div点击弹框，无论点击多少次，有且仅有一个弹窗出现（不会出一大堆重复窗）
    登陆案例：
    HTML: <div id="loginBtn"></div>
    JS: var createLogin=function () { //创建弹窗并隐藏 返回该弹窗DOM
        var div=document.createElement("div")
        div.innerHTML="<h1>login</h1>"
        div.style.display="none"
        document.body.appendChild(div)
        return div
    }
    var getSingle=function (fn) { //检查是否已经存在弹窗DOM
        var result
        return function () { //存在直接返回  不存在将this指向DOM（创建）
            return result || (result=fn.apply(this,arguments))
        }
    }
    document.getElementById("loginBtn").onclick=function () { //点击事件
        var loginLay=getSingle(createLogin) //获取DOM
        loginLay.style.display="block" //显示DOM
    }

    9.类和实例
    类：一个构造函数称为一个类
    实例：通过构造函数new出的对象，成为实例对象
    instanceof可以检查一个对象是否为一个类的实例 如：obj instanceof Person
    所有对象都是Object的后代 所以： 任何对象 instanceof Object 都为true
    es5:
    function  Animal(name) {
        this.name=name //构造函数属性
    }
    Animal.prototype.sayHi=function () { //构造函数原型方法
        console.log(this.name)
    }
    let dog = new Animal('dog') //dog就是Animal的实例对象
    es6:
    class Animal{
        constructor(name){ //构造函数属性
            this.name=name
        }
        sayHi(){ //等同于挂载到原型的方法
            console.log(this.name)
        }
    }
    let dog=new Animal('dog')
    Animal.prototype.constructor===Animal //true

    10.原型和原型链
    原型：每个js对象创建时（除了null）都会关联另一个对象，这个对象就是原型，每个对象都会从原型上继承属性。
    prototype：每个函数都有该属性，这个属性指向该函数的原型
    __proto__：每个对象都有该属性，这个属性指向该对象的原型 (原型对象也有，指向上一级原型对象)
    constructor：每个原型都有该属性，这个属性指向他所关联的构造函数
    即：
    Animal.prototype===dog.__proto__
    Animal===Animal.prototype.constructor
    Animal.prototype.constructor===dog.__proto__.constructor
    Animal.prototype.__proto__===dog.__proto__.__proto__
    原型链：查找属性时会在当前实例对象的原型上查找，找不到则使用__proto__自动向上级原型查找，直到找不到返回null（Object.prototype.__proto__）


    
</script>